@c This is part of the Radius manual.
@c Copyright (C) 1999-2025 Free Software Foundation, Inc.
@c Written by Sergey Poznyakoff
@c See file radius.texi for copying conditions.
@comment *******************************************************************
@node Extensions
@chapter Extensions
@cindex Extensions

The use of extension language allows extending the functionality of
GNU Radius without having to modify its source code. The two extension
languages supported are Rewrite and Scheme. Use of Rewrite is always
enabled. Use of Scheme requires Guile version 1.4 or higher.

@menu
* Filters::         Using external filter programs.
* Rewrite::         The built-in extension language.
* Guile::           Using Scheme.
@end menu

@comment *L1****************************************************************
@node Filters
@section Filters
@cindex Filters

The simplest way to extend the functionality of Radius is to use filters.
A filter is an external program that communicates with Radius via
its standard input and output channels.

@menu
* Getting Acquainted with Filters::
* Declaring the Filter::
* Invoking the Filter from a User Profile::
* Adding Reply Attributes::
* Accounting Filters::
* Invoking Accounting Filter::
@end menu

@node Getting Acquainted with Filters
@subsection Getting Acquainted with Filters

Suppose we wish to implement an authentication method based on the
user name and the user's calling station @acronym{ID}. We have a
database of user names with valid @acronym{ID}s, and the new
method should authenticate a user only if the combination
@{@var{user_name}, @var{id}@} is found in this database.

We write a filter program that reads its standard input line by line.
Each input line must consist of exactly two words: the user name
and the calling station @acronym{ID}. For each input line, the
program prints @code{0} if the @{@var{user_name}, @var{id}@} is found in the
database and @code{1} otherwise. Let's suppose for the sake of example
that the database is a plaintext file and the filter is written in
a shell programming language. Then it will look like

@example
#! /bin/sh

DB=/var/db/userlist

while read NAME CLID
do
    if grep "$1:$2" $DB; then
        echo "0"
    else
        echo "1"
    fi
done
@end example

@node Declaring the Filter
@subsection Declaring the Filter

Here is how this filter is declared in the @file{raddb/config} file:

@example
filters @{
    filter check_clid @{
        exec-path "/usr/libexec/myfilter";
        error-log "myfilter.log";
        auth @{
            input-format "%C@{User-Name@}
            %C@{Calling-Station-Id@}";
            wait-reply yes;
        @};
    @};
@};
@end example

Let's analyze this declaration line by line:

@enumerate
@item @code{filters @{}

This keyword opens the filters declaration block. The block may
contain several declarations.

@item @code{filter check_clid @{}

This line starts the declaration of this particular filter and names it
@samp{check_clid}.

@item @code{exec-path "/usr/libexec/myfilter";}

This line tells @command{radiusd} where to find the executable image of
this filter.

@item @code{error-log "myfilter.log";}

The diagnostic output from this filter must be redirected to the file
@file{myfilter.log} in the current logging directory

@item @code{auth @{}

This filter will process authentication requests.

@item @code{input-format "%C@{User-Name@} %C@{Calling-Station-Id@}";}

Define the input line format for this filter. The %C@{@} expressions
will be replaced by the values of the corresponding attributes from
the incoming request (@pxref{Macro Substitution}).

@item @code{wait-reply yes;}

@code{radiusd} will wait for the reply from this filter to decide whether to
authenticate the user.
@end enumerate

@node Invoking the Filter from a User Profile
@subsection Invoking the Filter from a User Profile

To invoke this filter from the user profile, specify its name prefixed
with @samp{|} in the value of @attr{Exec-Program-Wait} attribute,
like this:

@example
DEFAULT Auth-Type = System,
                Simultaneous-Use = 1
        Exec-Program-Wait = "|check_clid"
@end example

@node Adding Reply Attributes
@subsection Adding Reply Attributes

Apart from simply deciding whether to authenticate a user, the filter
can also modify the reply pairs.

@example
#! /bin/sh

DB=/var/db/userlist

while read NAME CLID
do
    if grep "$1:$2" $DB; then
        echo "0 Service-Type = Login, Session-Timeout = 1200"
    else
        echo "1 Reply-Message =
              \"You are not authorized to log in\""
    fi
done
@end example

@node Accounting Filters
@subsection Accounting Filters

Let's suppose we further modify our filter to also handle
accounting requests. To discern between the authentication and
accounting requests we'll prefix each authentication request
with the word @samp{auth} and each accounting request with
the word @samp{acct}. Furthermore, the input line for accounting
requests will contain a timestamp.

Now, our filter program will look as follows:

@example
#! /bin/sh

AUTH_DB=/var/db/userlist
ACCT_DB=/var/db/acct.db

while read CODE NAME CLID DATE
do
    case CODE
    auth)
        if grep "$1:$2" $DB; then
            echo "0 Service-Type = Login, \
                  Session-Timeout = 1200"
        else
            echo "1 Reply-Message = \
                  \"You are not authorized to log in\""
        fi
    acct)
        echo "$CODE $NAME $CLID $DATE" >> $ACCT_DB
done
@end example

Its declaration in the @file{raddb/config} will also change:

@example
filter check_clid @{
    exec-path "/usr/libexec/myfilter";
    error-log "myfilter.log";
    auth @{
        input-format "auth %C@{User-Name@}
                      %C@{Calling-Station-Id@}";
        wait-reply yes;
    @};
    acct @{
        input-format "acct %C@{User-Name@}
                      %C@{Calling-Station-Id@} %D";
        wait-reply no;
    @};
@};
@end example

@noindent
(The @code{input-format} lines are split for readability. Each of them
is actually one line).

@emph{Notice} @code{wait-reply no} in the @code{acct} statement. It
tells @command{radiusd} that it shouldn't wait for the response on
accounting requests from the filter.

@node Invoking Accounting Filter
@subsection Invoking the Accounting Filter

To invoke the accounting filter, specify its name prefixed with a
vertical bar character as a value of @attr{Acct-Ext-Program} in our
@file{raddb/hints} file. For example:

@example
DEFAULT NULL
        Acct-Ext-Program = "|check_clid":
@end example

@comment *L1****************************************************************
@node Rewrite
@section Rewrite
@cindex Rewrite

Rewrite is the GNU Radius extension language. Its name reflects the
fact that it was originally designed to rewrite broken request packets
so they could be processed as usual (@pxref{Rewriting Incoming
Requests}). Beside this basic use, however, Rewrite functions are used
to control various aspects of GNU Radius functionality, such as
verifying the activity of user sessions, controlling the amount of
information displayed in log messages, etc (@pxref{Interaction with Radius}).

@menu
* Syntax Overview::
* Quick Start::
* Interaction with Radius::
* Rewriting Incoming Requests::
* Login Verification Functions::
* Attribute Creation Functions::
* Logging Hook Functions::
* Full Syntax Description::
@end menu

@comment *L2****************************************************************
@node Syntax Overview
@subsection Syntax Overview
@cindex Rewrite, syntax overview

The syntax of Rewrite resembles that of C. Rewrite has two basic data types:
integer and string. It does not have global variables; all variables are
automatic. The only exceptions are the @AVP{}s from the incoming request,
which are accessible to Rewrite functions via the special notation
@code{%[@var{attr}]}.

@comment *L2****************************************************************
@node Quick Start
@subsection Quick Start
@cindex Rewrite, quick start introduction

As an example, let's consider the following Rewrite function:

@example
@group
string
foo(integer i)
@{
    string rc;
    if (i % 2)
        rc = "odd";
    else
        rc = "even";
    return "the number is " + rc;
@}
@end group
@end example

@noindent
The function takes an integer argument and returns the string
@samp{the number is odd} or @samp{the number is even}, depending on the
value of @code{i}. This illustrates the fact that in Rewrite the
addition operator is defined on the string type. The result of
such operation is the concatenation of operands.

Another example is a function that adds a prefix to the @attr{User-Name}
attribute:

@example
@group
integer
px_add()
@{
        %[User-Name] = "pfx-" + %[User-Name];
        return 0;
@}
@end group
@end example

@noindent
This function manipulates the contents of the incoming request; its
return value has no special meaning.


@comment *L2****************************************************************
@node Interaction with Radius
@subsection Interaction with Radius
@cindex Rewrite, usage
@cindex Rewrite, applying functions

A Rewrite function can be invoked in several ways, depending on its
purpose. There are four major kinds of Rewrite functions:

@itemize @bullet
@item Functions used to rewrite the incoming requests.
@item Functions designed for simultaneous login verification.
@item Functions used to generate Radius attribute values.
@item Logging hooks.
@end itemize

@comment *L3****************************************************************
@node Rewriting Incoming Requests
@subsection Rewriting Incoming Requests
@cindex Rewriting incoming requests

The need for rewriting incoming requests arises from the fact that
some @NAS{}es are very particular about the information they send with
the requests. There are cases when the information they send
is hardly usable or even completely unusable. For example, a
Cisco @sc{as5300} terminal server used as a voice-over IP router packs
a lot of information into its @attr{Acct-Session-Id} attribute. Though
the information stored there is otherwise relevant, it makes proper
accounting impossible, since the @attr{Acct-Session-Id} attributes
in the start and stop packets of the same session become different, and
thus Radius cannot determine the session start to which the given
session stop request corresponds (@pxref{Acct-Session-Id}).

In order to cope with such @NAS{}es, GNU Radius is able to invoke
a Rewrite function upon arrival of the packet and before
processing it further. This function can transform the packet so that
it obtains the form prescribed by @sc{rfc}s and its further processing
becomes possible.

For example, in the case of the @sc{as5300} router, a corresponding Rewrite
function parses the @attr{Acct-Session-Id} attribute; breaks it
down into fields; stores them into proper attributes, creating
them if necessary; and finally replaces @attr{Acct-Session-Id} with
its real value, which is the same for the start and stop records
corresponding to a single session. Thus all the information that
came with the packet is preserved, but the packet itself is made
usable for proper accounting.

A special attribute, @attr{Rewrite-Function}, is used to trigger
invocation of a Rewrite function. Its value is a name of the
function to be invoked.

When used in a @file{naslist} profile, the attribute causes the function
to be invoked when the incoming request matches the huntgroup
(@pxref{Huntgroups}). For example, to have a function @code{fixup}
invoked for each packet from the @NAS{} @code{10.10.10.11}, the
following huntgroup rule may be used:

@example
@group
DEFAULT  NAS-IP-Address = 11.10.10.11
         Rewrite-Function = "fixup"
@end group
@end example

The @attr{Rewrite-Function} attribute may also be used in a @file{hints}
rule. In this case, it will invoke the function if the request matches
the rule (@pxref{Hints}). For example, this @file{hints} rule will
cause the function to be invoked for each request whose user name
starts with @samp{P}:

@example
@group
DEFAULT  Prefix = "P"
         Rewrite-Function = "fixup"
@end group
@end example

@noindent
Note that in both cases the attribute can be used
either in @LHS{} or in @RHS{} pairs of a rule.

The packet rewrite function must be declared as having no arguments
and returning an integer value:

@example
@group
integer fixup()
@{
@}
@end group
@end example

@noindent
The actual return value from such a function is ignored, the integer
return type is just a matter of convention.

The following subsection presents some examples of packet rewrite
functions.

@menu
* Example: Rewrite Examples.
@end menu

@comment **L3***************************************************************
@node Rewrite Examples
@subsubsection Examples of Various Rewrite Functions
@exindex Rewrite functions

The examples found in this chapter are working functions that can be
used with various existing @NAS{} types. They are taken from the
@file{rewrite} file contained in distribution of GNU Radius.

@subsubheading 1. Port rewriting for @sc{max a}scend terminal servers

Some @sc{max a}scend terminal servers pack additional information
into the @attr{NAS-Port-Id} attribute. The port number is constructed as
@var{XYYZZ}, where @var{X} = 1 for digital, @var{X} = 2 for analog,
@var{YY} is the line number
(1 for first PRI/T1/E1, 2 for second, and so on), and @var{ZZ} is the
channel number
(on the PRI or channelized T1/E1).

The following rewrite functions are intended to compute the integer
port number in the range [1, @var{portcnt}], where @var{portcnt}
represents the real number of physical ports available on the @NAS{}.
Such a port number can be used, for example, to create a dynamic pool
of IP addresses (@pxref{Framed-IP-Address}).

@example
@group
/*
 * decode MAX port number
 * input: P        --  The value of NAS-Port-Id attribute
 *        portcnt  --  number of physical ports on the NAS
 */
integer
max_decode_port(integer P, integer portcnt)
@{
    if (P > 9999) @{
        integer s, l, c;

        s = P / 10000;
        l = (P - (10000 * s))/100;
        c = P - ((10000 * s) + (100 * l));
        return (c-1) + (l-1) * portcnt;
    @}
    return P;
@}
@end group

@group
/*
 * Interface function for MAX terminal server with 23 ports.
 * Note that it saves the received NAS-Port-Id attribute in
 * the Orig-NAS-Port-Id attribute. The latter must be
 * defined somewhere in the dictionary
 */
integer
max_fixup()
@{
    %[Orig-NAS-Port-Id] = %[NAS-Port-Id];
                                  # Preserve original data
    %[NAS-Port-Id] = max_decode_port(%[NAS-Port-Id], 23);
    return 0;
@}
@end group
@end example

@subsubheading 2. Session @sc{id} parsing for Cisco AS 5300 series

Cisco @sc{voip ios} encodes a lot of other information into its
@attr{Acct-Session-Id}. The pieces of information are separated by
@samp{/} characters. The part of @attr{Acct-Session-Id} up to the first
@samp{/} character is the actual session @sc{id}.

On the other hand, its accounting packets lack @attr{NAS-Port-Id},
though they may contain the vendor-specific pair with code 2
(vendor @sc{pec} 9), which is a string in the form @samp{ISDN 9:D:999}
(@samp{9} represents any decimal digit). The number after the last
@samp{:} character can be used as a port number.

The following code parses @attr{Acct-Session-Id} attribute and stores
the information it contains in various other attributes, generates a
normal @attr{Acct-Session-Id}, and attempts to generate a
@attr{NAS-Port-Id} attribute.

@example
@group
/*
 * The port rewriting function for Cisco AS5300 used for
 * VoIP. This function is used to generate NAS-Port-Id pair
 * on the basis of vendor-specific pair 2. If the latter is
 * in the form "ISDN 9:D:999" (where each 9 represents a
 * decimal digit), then the function returns the number
 * after the last colon. This is used as a port number.
 */
integer
cisco_pid(string A)
@{
    if (A =~
        ".*\([0-9][0-9]*\):
         [A-Z0-9][A-Z0-9]*:\([0-9][0-9]*\)") @{
        return (integer)\2;
    @}
    return -1;
@}
@end group

@group
/*
 * This function parses the packed session id.
 * The actual sid is the number before the first slash
 * character.  Other possibly relevant fields are also
 * parsed out and saved in the Voip-* A/V pairs. The latter
 * should be defined somewhere in the dictionary.
 * Note that the regular expression in this example
 * spans several lines for readability. It should be on one
 * line in real file.
 */
string
cisco_sid(string S)
@{
   if (S =~ "\(.[^/]*\)/[^/]*/[^/]*/\([^/]*\)/\([^/]*\)/
             \([^/]*\)/\([^/]*\)/\([^/]*\)/\([^/]*\)
             /\([^/]*\).*") @{
        %[Voip-Connection-ID] = \2;
        %[Voip-Call-Leg-Type] = \3;
        %[Voip-Connection-Type] = \4;
        %[Voip-Connect-Time] = \5;
        %[Voip-Disconnect-Time] = \6;
        %[Voip-Disconnect-Cause] = \7;
        %[Voip-Remote-IP] = \8;
        return \1;
   @}
   return S;
@}
@end group

@group
/*
 * Normalize cisco AS5300 packets
 */
integer
cisco_fixup()
@{
    integer pid;

    if ((pid = cisco_pid(%[Cisco-PRI-Circuit])) != -1) @{
        if (*%[NAS-Port-Id])
            %[Orig-NAS-Port-Id] = %[NAS-Port-Id];
        %[NAS-Port-Id] = pid;
    @}
    if (*%[Acct-Session-Id]) @{
        %[Orig-Acct-Session-Id] = %[Acct-Session-Id];
        %[Acct-Session-Id] = cisco_sid(%[Acct-Session-Id]);
    @}
    return 0;
@}
@end group
@end example

@subsubheading 3. User-name rewriting for @sc{nt} machines

Users coming from Windows @sc{nt} machines often authenticate themselves as
@samp{NT_DOMAIN\@var{username}}. The following function selects the
user-name part and stores it in the @attr{User-Name} attribute:

@example
@group
integer
login_nt(string uname)
@{
    integer i;

    if ((i = index(uname, '\\')) != -1)
        return substr(uname, i+1, -1);
    return uname;
@}

integer
nt_rewrite()
@{
    %[Orig-User-Name] = %[User-Name];
    %[User-Name] = login_nt(%[User-Name]);
    return 0;
@}
@end group
@end example

@comment *L2**************************************************************
@node Login Verification Functions
@subsection Login Verification Functions
@cindex Rewrite, login verification functions

A login verification function is invoked to process the output from the
@NAS{}. This process is described in @ref{Multiple Login Checking}.
The function to be invoked for given @NAS{} is defined by
a @code{function} flag in the @file{raddb/nastypes} or @file{raddb/naslist}
file (@pxref{nastypes file}). It must be defined as follows:

@deftypefn {Function Template} integer check (string @var{str}, string @var{name}, integer @var{pid}, string @var{sid})
@end deftypefn

@noindent
Its arguments are:

@table @var
@item str
Input string. If the query method is @code{finger}, this is the string
of output received from the @NAS{} with trailing newline stripped off. If
the query method is @code{snmp}, it is the received variable value
converted to its string representation.
@item name
User name.
@item pid
Port @sc{id} of the session.
@item sid
Session @sc{id}.
@end table

The function should return non-0 if its arguments match the user's
session, and 0 otherwise.

@menu
* Example: Examples of Login Verification Functions
@end menu

@comment **L4*************************************************************
@node Examples of Login Verification Functions
@subsubsection Examples of Login Verification Functions
@exindex Login verification functions

@exindex Checking UNIX @code{finger} output
As an example, let's consider the function for analyzing a
line of output from a standard @acronym{UNIX} @code{finger}
service. In each line of @code{finger} output, the first field
contains the user name; the third field, the
tty number (port @sc{id}); and the seventh field, the session @sc{id}.
The function must return 1 if the three fields match the input
user name, as well as its port and session @sc{id}s:

@example
integer
check_unix(string str, string name, integer pid, string sid)
@{
    return field(str, 1) == name
           && field(str, 3) == pid
           && field(str, 7) == sid;
@}
@end example

@c @xref{UNIX Finger}.

@exindex Analyzing SNMP output
The next example is a function to analyze a line of output from an SNMP
query returning a user name. This function must return 1 if the entire input
line matches the user name:

@example
integer
check_username(string str, string name, integer pid, string sid)
@{
    return str == name;
@}
@end example

@comment **L3***************************************************************
@node Attribute Creation Functions
@subsection Attribute Creation Functions
@cindex Rewrite, attribute creation functions

These are the functions used to create Radius reply attributes. An
attribute creation function can take any number of arguments. The type
of its return is determined by the type of Radius attribute the
value will be assigned to. To invoke the function, write its name
in the @AVP{} of the @RHS{} in the @file{raddb/users} file, e.g.:

@example
@group
DEFAULT Auth-Type = SQL
        Service-Type = Framed-User,
            Framed-IP-Address = "=get_ip_addr(10.10.10.1)"
@end group
@end example

@noindent
The function @code{get_ip_addr} will be invoked after successful
authentication and it will be passed the IP @code{10.10.10.1} as its
argument. In @command{Rewrite} language, an IPv4 address is
represented as a 32-bit integer number, and can be operated upon as
any other integer. This is illustrated in the following function,
which can be used to compute the value of the @code{Framed-IP-Address}
above:

@example
@group
@exindex IP pools for MAX Ascend
integer
get_ip_address(integer base)
@{
    return base + %[NAS-Port-Id] - %[NAS-Port-Id]/16;
@}
@end group
@end example

@comment **L3***************************************************************
@node Logging Hook Functions
@subsection Logging Hook Functions
@cindex Rewrite, Logging Hook Functions

A logging hook functions should be declared as follows:

@deftypefn {Function Template} string hook (integer @var{reqtype}, string @var{nasid}, integer @var{reqid})
@table @var
@item reqtype
Type of the request. It can be converted to string using
@code{request_code_string} function (@pxref{Built-in Functions}).
@item nasid
@NAS{} identifier from @file{raddb/naslist}, or its host name if not
declared there
@item reqid
Request identifier.
@end table
@end deftypefn

Notice that the hook function @emph{shall not} produce any side effects,
in particular it shall not modify the incoming request in any way.

Following is an example prefix hook function that formats the
incoming request data:

@example
string
compat_log_prefix(integer reqtype, string nas, integer id)
@{
        string result;

        return "(" + request_code_string(reqtype) + " "
                   + nas + " " + (string)id + " " + %[User-Name] + ")";
@}
@end example

Here is a sample log produced by @command{radiusd} before and after
enabling this function:

@example
@cartouche
Auth.notice: Login OK [jsmith]
@dots{}
Auth.notice: (AUTHREQ nas-2 251 jsmith): Login OK [jsmith]
@end cartouche
@end example

@comment *L2****************************************************************
@node Full Syntax Description
@subsection Full Syntax Description
@cindex Rewrite, syntax of the language

@menu
* Data types::
* Symbols::
* Identifiers::
* Expressions::
* Type coercion::
* Assignments::
* Declarations::
* Statements::
* Function calls::
* Delete statement::
* Regular Expressions::
* Built-in Functions::
@end menu

@comment **L4***************************************************************
@node Data types
@subsubsection Rewrite Data Types
@cindex Data types, Rewrite
@cindex Rewrite, data types

There are only two data types: @code{integer} and @code{string},
the two being coercible to each other in the sense that a string
can be coerced to an integer if it contains a valid @sc{ascii} representation
of a decimal, octal, or hex number, and an integer can always be coerced
to a string, the result of such coercion being the @sc{ascii} string
that is the
decimal representation of the number.

@comment **L4***************************************************************
@node Symbols
@subsubsection Rewrite Symbols
@cindex Symbols, Rewrite
@cindex Rewrite, symbols

A @dfn{symbol} is a lexical token. The following symbols are recognized:

@table @asis
@item Arithmetical operators
These are @samp{+}, @samp{-}, @samp{*}, @samp{/} representing the basic
arithmetical operations, and @samp{%} meaning remainder.
@item Comparison operators
These are: @samp{==}, @samp{!=}, @samp{<}, @samp{<=}, @samp{>},
@samp{>=} with the same meaning they have in C. Special operators
are provided for regular-expression matching. The binary
operator @samp{=~} returns true if its left-hand-side operand
matches the regular expression on its right-hand side
(@pxref{Regular Expressions}). @samp{!~} returns true if its
left-hand-side operand does @emph{not} match
the regexp on its right-hand side. The right-hand-side operand of
@samp{!~} or @samp{=~} must be a literal string, i.e., the regular
expression must be known at compile time.
@item Unary operators
The unary operators are @samp{-} and @samp{+} for unary plus and minus,
@samp{!} for boolean negation, and @samp{*} for testing for the
existence of an attribute.
@item Boolean operators
These are @samp{&&} and @samp{||}.
@item Parentheses @samp{(} and @samp{)}
These are used to change the precedence of operators, to introduce
type casts (type coercions), to declare functions, and to pass actual
arguments to functions.
@item Curly braces (@samp{@{} and @samp{@}})
These are used to delimit blocks of code.
@item Numbers
Numbers follow the usual C convention for integers. A number consisting of
a sequence of digits is taken to be octal if it begins with @samp{0}
(digit zero), and decimal otherwise. If the sequence of digits is
preceded by @samp{0x} or @samp{0X}, it is taken to be a hexadecimal
integer.
@item IP Numbers
IP numbers are represented by a standard numbers-and-dots notation.
IP numbers do not constitute a separate data type, rather they are
in all respects similar to integer numbers.
@item Characters
These follow the usual C convention for characters, i.e., they consist
either of
an @sc{ascii} character itself or of its value, enclosed in a pair of
single quotes.
The character value begins with @samp{\} (backslash) and
consists either of three octal or of two hexadecimal digits.
A character does not form a special data type; it is represented
internally by an integer.
@item Quoted strings
These follow slightly modified C conventions for strings. A string is
a sequence of characters surrounded by double quotes, as in
@samp{"..."}. In a string, the double quote character @samp{"} must be
preceded by a backslash @samp{\}. A @samp{\} and an immediately following
newline are ignored. Following escape sequences have special meaning:

@table @asis
@item \a
Audible bell character (ASCII 7)
@item \b
Backspace (ASCII 8)
@item \e
Escape character (ASCII 27)
@item \f
Form feed (ASCII 12)
@item \n
Newline (ASCII 10)
@item \r
Carriage return (ASCII 13)
@item \t
Horizontal tab (ASCII 9)
@item \\
Backslash
@item \ooo
(@samp{o} represents an octal digit)
A character whose ASCII value is represented by the octal number @samp{ooo}.
@item \xHH
@itemx \XHH
(@samp{H} represents a hex digit)
A character whose ASCII value is represented by the hex number @samp{HH}.
@item \(
Two characters @samp{\(}.
@item \)
Two characters @samp{\)}.
@end table

If the character following the backslash is not one of those
specified, the backslash is ignored.


@item Attribute values
The incoming request is passed implicitly to functions invoked via the
@attr{Rewrite-Function} attribute. It is kept as an associative array,
whose entries can be accessed using the following syntax:

@example
@samp{%[} @var{attribute-name} @samp{]}
@samp{%[} @var{attribute-name} @samp{]} @samp{(} @var{n} @samp{)}
@end example

@noindent
The first form returns the value of the attribute @var{attribute-name}.
Here @var{attribute-name} should be a valid Radius dictionary name
(@pxref{dictionary file}).

The second form returns the value of the @var{n}th attribute of type
@var{attribute-name}. The index @var{n} is counted from zero, so

@example
        %[@var{attribute-name}](0)
@end example

@noindent
is equivalent to

@example
        %[@var{attribute-name}]
@end example

@item Identifiers
Identifiers represent functions and variables. These are described in
the next sub-subsection.
@item Regexp group references
A sequence of characters in the form

@example
@samp{\@var{number}}
@end example

@noindent

refers to the contents of parenthesized group number @var{number}
obtained as a result of the last executed @samp{=~} command.
The regexp group reference has always string data type. For example:

@example
@group
string
basename(string @var{arg})
@{
    if (arg =~ ".*/\(.*\)\..*")
        return \1;
    else
        return arg;
@}
@end group
@end example

This function strips from @var{arg} all leading components up to the
last slash character, and all trailing components after the last dot
character. It returns @var{arg} unaltered if it does not contain
slashes and dots. It is roughly analogous to the system @code{basename}
utility.
@end table

@comment **L4***************************************************************
@node Identifiers
@subsubsection Rewrite Identifiers
@cindex Identifiers, Rewrite
@cindex Rewrite identifiers

A valid identifier is a string of characters meeting the following
requirements:

@enumerate 1
@item It starts with either a lower- or an uppercase letter of the Latin
alphabet or either of the following symbols: @samp{_}, @samp{$}.
@item It consists of alphanumeric characters, underscores(@samp{_}), and
dollar signs (@samp{$}).
@end enumerate

@node Expressions
@subsubsection Rewrite expressions
@cindex Expressions, Rewrite
@cindex Rewrite Expressions

A unary expression is a unary operator, followed by a single operand.
A binary expression consists of two operands with a binary operator
between them.

The following table ranges all operators according to their
precedence (from lowest to highest).  All operators are
left-associative, except as noted otherwise.

@enumerate 1
@item @code{=} (assignment, right-associative, @pxref{Assignments})
@item @code{||}
@item @code{&&}
@item @code{=~}, @code{!~} (non-associative)
@item @code{|}
@item @code{^}
@item @code{&}
@item @code{==}, @code{!=}
@item @code{<}, @code{<=}, @code{>}, @code{>=}
@item @code{<<}, @code{>>}
@item @code{+}, @code{-}
@item @code{*}, @code{/}, @code{%}
@item unary @code{-}, @code{!}
@end enumerate

@node Type coercion
@subsubsection Type coercion
@cindex type coercion
The type coercion is like a type cast in C. Its syntax is

@example
@samp{(} @var{type} @samp{)} @var{ident}
@end example

Type coercion associates left, and has the same precedence as unary
negation operators (i.e. the highest one).

The result of type coercion is as follows:

@multitable @columnfractions .20 .20 .60
@item @var{type} @tab Variable type @tab Resulting conversion

@item integer
@tab integer
@tab No conversion. This results in the same integer value.

@item integer
@tab string
@tab If the string value of the variable is a valid @sc{ascii} representation
of the integer number (either decimal, octal, or hex), it is converted to
the integer; otherwise the result of the conversion is undefined.

@item string
@tab integer
@tab The @sc{ascii} representation (in decimal) of the integer number.

@item string
@tab string
@tab No conversion. This results in the same string value.

@end multitable

@node Assignments
@subsubsection Assignments
@cindex assignment, rewrite
The @code{=} operator denotes an assignment. Syntactically, the
assignment is

@example
@var{ident} = @var{expression} ;
@end example

As a result of this statement, the variable @var{ident} is assigned
the value of @var{expression}.  When used in expressions, assignments
associate right and has the lowest precedence.

@comment **L4***************************************************************
@node Declarations
@subsubsection Rewrite Declarations
@cindex Declarations, Rewrite

@subsubheading Function declarations

A Rewrite function is declared as follows:

@example
@var{type} @var{function-name} (@var{parameter-list})
@end example

@noindent
where @var{type} specifies the return type of the function,
@var{function-name} declares the symbolic name of the function, and
@var{parameter-list} declares the formal parameters to the function.
It is a comma-separated list of declarations in the form

@example
@var{type} @var{parm-name}
@end example

@noindent
@var{type} being the parameter type, and @var{parm-name} being its
symbolic name. Both @var{function-name} and @var{parm-name} should
be valid identifiers.

@subsubheading Variable declarations

There are no global variables in Rewrite. All variables are local.
The local variables are declared right after the opening curly brace
(@samp{@{}) and before any executable statements. The declaration
syntax is

@example
@var{type} @var{ident_list} ;
@end example

@noindent
Here @var{ident_list} is either a valid Rewrite identifier or a
comma-separated list of such identifiers.

Note that, unlike in
C, no assignments are allowed in variable declarations.

@comment **L4***************************************************************
@node Statements
@subsubsection Rewrite Statements
@cindex Statements, Rewrite

The Rewrite statements are: expressions, conditionals, loops, and return
statements. A @dfn{simple statement} is terminated by a semicolon.  A
@dfn{compound statement} is one or more statements enclosed in curly
brackets.

@subsubheading Conditionals
@cindex conditionals
A conditional statement is:

@example
@group
if (@var{expr})
  @var{a}
else
  @var{b}
@end group
@end example

@noindent
Here, @var{expr} is any expression, @var{a} and @var{b} are statements
(simple or compound).  The expression @var{expr} is evaluated and its
result is coerced to boolean value.  If the resulting value is
@samp{true}, then the statement @var{a} is executed, otherwise, the
statement @var{b} is executed.  The @code{else} part is optional.
Conditional expressions can be chained:

@example
@group
if (@var{e1})
  @var{a};
else if (@var{e2})
  @var{b};
else if (@var{e3})
  @var{c};
else
  @var{d};
@end group
@end example

This is equivalent to

@example
@group
if (@var{e1})
  @var{a};
else @{
  if (@var{e2})
    @var{b};
  else @{
    if (@var{e3})
      @var{c};
    else
      @var{d};
  @}
@}
@end group
@end example

@subsubheading Loops
@cindex loops
Two kinds of loops are provided: @dfn{while}, and @dfn{do-while}
loops.

A @dfn{while} loop is:

@example
while (@var{expr}) @var{stmt}
@end example

A @dfn{do-while} loop is:

@example
do @var{stmt} while (@var{expr})
@end example

Both loops run @var{stmt} (which is usually a compound statement)
for as long as @var{expr} evaluates to @samp{true}.  The main
difference is that a while loop is executed 0 or more times, while a
do-while loop is executed 1 or more times.

The following statements can appear within a @var{stmt} in a loop:

@table @code
@item break
@kwindex break
Break from the loop immediately. Control flow resumes at the first
statement after the loop.

@item continue
@kwindex continue
Branch to @var{expr} immediately.
@end table

@subsubheading The @code{return} statement
@kwindex return

@example
return @var{expr}
@end example

The @code{return} statement stops execution of the current function
and returns to the caller.  Its argument is evaluated and the
resulting value becomes the function return value.

@node Function calls
@subsubsection Function calls
@cindex function call, rewrite
These take the form

@example
@var{ident} ( @var{arg-list} )
@end example

@noindent
where @var{ident} is the identifier representing the function, and
@var{arg-list} is a comma-separated list of expressions supplying
actual arguments to the function. The number of the expressions
must correspond exactly to the number of formal parameters in the
function definition. The function that @var{ident}
references can be either a compiled function or a built-in
function.

@node Delete statement
@subsubsection @samp{delete} statement
@kwindex delete

The @samp{delete} statement is used to delete an attribute or attributes
from the incoming request. Its syntax is:

@example
delete @var{attribute-name};
delete @var{attribute-name}(@var{n});
@end example

The first variant deletes @emph{all} the attributes of the given type.
The second variant deletes only the @var{n}th occurrence of the matching
attribute.

@comment **L4***************************************************************
@node Regular Expressions
@subsubsection Regular Expressions
@cindex Regular Expressions, Rewrite

Rewrite uses POSIX regular expressions
(@xref{Top,,Regular Expression Library,regex,Regular Expression
Library}, for the detailed description of these).

You control the exact type of regular expressions by the use of the
pragmatic comment @code{regex}. Its syntax is as follows:

@example
#pragma regex @var{option-list}
@end example

@noindent
@var{Option-list} is a whitespace-separated list of options. Each option
is one of the following words prefixed with @samp{+} or @samp{-}:

@table @code
@item extended
Use POSIX extended regular expression syntax when interpreting regular
expressions.

@item icase
Do not differentiate case. Subsequent regular expression comparisons
will be case insensitive.

@item newline
Match-any-character operators don't match a newline.

A non-matching list (@samp{[^...]}) not containing a newline does
not match a newline.

Match-beginning-of-line  operator  (@samp{^}) matches the empty string
immediately after a newline.

Match-end-of-line operator (@samp{$}) matches the empty string
immediately before a newline.

@end table

Prefixing an option with @samp{+} means to enable the corresponding
behavior. Prefixing it with @samp{-} means to disable it. Thus,
the following statement:

@example
#pragma regex +extended +icase
@end example

@noindent
will enable extended POSIX regular expressions using case-insensitive
comparison.

Using the following comment:

@example
#pragma regex -extended
@end example

@noindent
will switch to the basic POSIX regular expressions.

The settings of a @code{regex} pragmatic comment remain in force up to
the end of current source file, or to the next @code{regex} comment,
whichever occurs first.

For compatibility with previous versions, GNU Radius uses
the following defaults:

@example
#pragma regex -extended -icase -newline
@end example

@noindent
i.e. all regular expressions are treated as basic POSIX, comparison
is case-sensitive.

@comment **L4***************************************************************
@node Built-in Functions
@subsubsection Rewrite Built-in Functions
@cindex Built-in functions, Rewrite

The following built-in functions are provided:

@deftypefn Function integer length (string @var{s})
Returns the length of the string @var{s}.

@example
length("string") @result{} 6
@end example
@end deftypefn

@deftypefn Function integer index (string @var{s}, integer @var{c})
Returns the index of the first occurrence of the character @var{c} in
the string @var{s}. Returns @minus{}1 if no such occurrence is found.

@example
index("/raddb/users", 47) @result{} 0

index("/raddb/users", 45) @result{} @minus{}1
@end example
@end deftypefn

@deftypefn Function integer rindex (string @var{s}, integer @var{i})
Returns the index of the last occurrence of the character @var{c} in
the string @var{s}. Returns @minus{}1 if no such occurrence is found.

@example
rindex("/raddb/users", 47) @result{} 6
@end example
@end deftypefn

@deftypefn Function string substr (string @var{s}, integer @var{start}, integer @var{length})
Returns the substring of @var{s} of length at most @var{length} starting at
position @var{start}.

@example
substr("foo-bar-baz", 3, 5) @result{} "-bar-"
@end example
@end deftypefn

All character positions in strings are counted from 0.

@deftypefn Function string field (string @var{buffer}, integer @var{n})
This function regards the @var{buffer} argument as consisting of
fields separated with any amount of whitespace. It extracts and
returns the @var{n}th field. @var{n} is counted from 1.

@example
field("GNU's not UNIX", 1) @result{} "GNU's"
field("GNU's not UNIX", 2) @result{} "not"
field("GNU's not UNIX", 3) @result{} "UNIX"
field("GNU's not UNIX", 4) @result{} ""
@end example
@end deftypefn

@deftypefn Function integer logit (string @var{msg})
Outputs its argument to the Radius log channel @code{info}. Returns 0.
For debugging purposes.
@end deftypefn

@deftypefn Function integer inet_aton (string @var{str})
Converts the Internet host address @var{str} from the
standard numbers-and-dots notation into the equivalent integer in
host byte order.

@example
inet_aton("127.0.0.1") @result{} 2130706433
@end example
@end deftypefn

@deftypefn Function string inet_ntoa (integer @var{ip})
Converts the Internet host address @var{ip} given
in host byte order to a string in standard numbers-and-dots notation.

@example
inet_ntoa(2130706433) @result{} "127.0.0.1"
@end example
@end deftypefn

@deftypefn Function integer htonl (integer @var{n})
Converts the integer @var{n}, regarded as long, from host to network byte
order.
@end deftypefn

@deftypefn Function integer ntohl (integer @var{n})
Converts the integer @var{n}, regarded as long, from network to host byte
order.
@end deftypefn

@deftypefn Function integer htons (integer @var{n})
Converts the integer @var{n}, regarded as short, from host to network byte
order.
@end deftypefn

@deftypefn Function integer ntohs (integer @var{n})
Converts the integer @var{n}, regarded as short, from network to host byte
order.
@end deftypefn

@deftypefn Function string gsub (string @var{regex}, string @var{repl}, string @var{str})
For each substring matching the regular expression @var{regex} in the string
@var{str}, substitute the string @var{repl}, and return the resulting
string.

@example
gsub("s","S","strings")
    @result{} "StringS"
gsub("[0-9][0-9]*","N","28 or 29 days")
    @result{} "N or N days"
gsub("[()'\"]","/","\"a\" (quoted) 'string'")
    @result{} "/a/ /quoted/ /string/"
@end example
@end deftypefn

@deftypefn Function string qprn (string @var{str})
Replace all non-printable characters in string S by their
corresponding hex value preceded by a percent sign. Return the
resulting string. Printable are alphabetical characters, decimal
digits and dash (@samp{-}). Other characters are considered non-printable.
For example:

@example
qprn("a string/value") @result{} "a%20string%2Fvalue"
@end example
@noindent
@end deftypefn

@deftypefn Function string quote_string (string @var{str})
Replace all non-printable characters in string @var{str} by their
three-digit octal code prefixed with a backslash, or by their C
escape notation, as appropriate. @dfn{Non-printable} characters
depend on the locale settings. For example, suppose that the current
locale is set to ISO-8859-1 (a so called ``Latin-1'' character set)
and @point{} represents a tab character. Then:

@example
quote_string("Fran@,{c}ois contains non@point{}printable chars")
  @result{} "Fran\347ois contains non\tprintable chars"
@end example
@end deftypefn

@deftypefn Function string unquote_string (string @var{str})
Replace C escape notations in string @var{str} with corresponding
characters using current locale. For example, for ISO-8859-1 locale:

@example
unquote_string("Fran\347ois") @result{} "Fran@,{c}ois"
@end example
@end deftypefn

@deftypefn Function string toupper (string @var{str})
Returns the copy of the string @var{str} with all alphabetical characters
converted to upper case. For example:

@example
toupper("a-string") @result{} "A-STRING"
@end example
@end deftypefn

@deftypefn Function string tolower (string @var{str})
Returns the copy of the string @var{str} with all alphabetical characters
converted to lower case. For example:

@example
tolower("A-STRING") @result{} "a-string"
@end example
@end deftypefn

@deftypefn Function string request_code_string (integer @var{code})
Converts integer RADIUS request code to its textual representation as
per RFC 3575. This function is useful in logging hooks (@pxref{hooks}).

@example
request_code_string(4) @result{} "Accounting-Request"
@end example
@end deftypefn

@subheading Native Language Support

The native language support is provided via the functions described
below. These functions are interfaces to GNU @code{gettext} library.
For the information about general concepts and principles of
Native Language Support, please refer to
@ref{Top,GNU @code{gettext} utilities,gettext,gettext,GNU @code{gettext} utilities}.

The default current textual domain is @samp{radius}.

@deftypefn Function string textdomain (string @var{domain})
Sets the new value for the current textual domain. This domain is used by
the functions @code{gettext} and @code{ngettext}.
Returns the name of the previously used domain.
@end deftypefn

@deftypefn Function string gettext (string @var{msgid})
@deftypefnx Function string _ (string @var{msgid})
The function returns the translation of the string @var{msgid} if it
is available in the current domain. If it is not available, the
argument itself is returned.

The second form of this function provides a traditional shortcut
notation.

For a detailed description of the GNU @code{gettext} interface,
refer to @ref{Interface to gettext,,,gettext,GNU @code{gettext} utilities}.
@end deftypefn

@deftypefn Function string dgettext (string @var{domain}, string @var{msgid})
Returns the translation of the string @var{msgid} if it
is available in the domain @var{domain}. If it is not available, the
argument itself is returned.
@end deftypefn

@deftypefn Function string ngettext (string @var{msgid_singular}, string @var{msgid_plural}, integer @var{number})
The @code{ngettext} function is used to translate the messages that
have singular and plural forms. The @var{msgid_singular} parameter
must contain the singular form of the string to be converted. It is
also used as the key for the search in the catalog. The
@code{msgid_plural} parameter is the plural form.  The parameter
@var{number} is used to determine the plural form. If no message
catalog is found @var{msgid_singular} is returned if
@code{@var{number} == 1}, otherwise @var{msgid_plural}.

For a detailed description of the GNU @code{gettext} interface for the
plural translation,
refer to @ref{Plural forms,,Additional functions for plural forms,gettext,GNU @code{gettext} utilities}.

@end deftypefn

@deftypefn Function string dngettext (string @var{domain}, string @var{msg_sing}, string @var{msg_plur}, integer @var{number})
Similar to @code{ngettext}, but searches translation in the given @var{domain}.
@end deftypefn

@subheading Request Accessors

The following functions are used to read some internal fields of a
@RADIUS{} request.

@deftypefn Function Integer request_source_ip ()
Returns source @IP{} of the currently processed request. This function
can be used to add @attr{NAS-IP-Address} attribute to the requests
lacking one, e.g.:

@example
integer
restore_nas_ip()
@{
        if (!*%[NAS-IP-Address])
                %[NAS-IP-Address] = request_source_ip();
        return 0;
@}
@end example
@end deftypefn

@deftypefn Function Integer request_source_port ()
Returns the source @sc{udp} port.
@end deftypefn

@deftypefn Function Integer request_id ()
Returns the request identifier.
@end deftypefn

@deftypefn Function Integer request_code ()
Returns the request code.
@end deftypefn

@comment *L1****************************************************************
@node Guile
@section Guile
@cindex Guile

The name Guile stands for @dfn{GNU's Ubiquitous Intelligent Language for
Extensions}. It provides a Scheme interpreter conforming to the R4RS
language specification. This section describes use of Guile as an
extension language for GNU Radius. It assumes that the reader is
sufficiently familiar with the Scheme language. For information about
the language, refer to
@ref{Top,,,r4rs,Revised(4) Report on the Algorithmic Language Scheme}.
For more information about Guile, see @ref{Top,,Overview,guile,The Guile Reference Manual}.

Scheme procedures can be called for processing both authentication
and accounting requests. The invocation of a Scheme procedure for an
authentication request is triggered by the @attr{Scheme-Procedure}
attribute; the invocation for an accounting request is triggered
by the @attr{Scheme-Acct-Procedure} attribute. The following sections
address these issues in more detail.

@menu
* Data Representation::
* Authentication with Scheme::
* Accounting with Scheme::
* Radius-Specific Functions::
@end menu

@comment **L2***************************************************************
@node Data Representation
@subsection Data Representation
@cindex Guile, representation of Radius data

@AVP{} lists are the main object Scheme functions operate upon. Scheme
is extremely convenient for representation of such objects. A Radius @AVP{}
is represented by a Scheme pair; e.g.,

@example
        Session-Timeout = 10
@end example

@noindent
is represented in Guile as

@smalllisp
        (cons "Session-Timeout" 10)
@end smalllisp

The @code{car} of the pair can contain either the attribute dictionary
name or the attribute number. Thus, the above pair may also be
written in Scheme as

@smalllisp
        (cons 27 10)
@end smalllisp

@noindent
(because @attr{Session-Timeout} corresponds to attribute number 27).

Lists of @AVP{}s are represented by Scheme lists. For example,
the Radius pair list

@example
@group
        User-Name = "jsmith",
                User-Password = "guessme",
                NAS-IP-Address = 10.10.10.1,
                NAS-Port-Id = 10
@end group
@end example

@noindent
is written in Scheme as

@smalllisp
@group
        (list
          (cons "User-Name" "jsmith")
          (cons "User-Password" "guessme")
          (cons "NAS-IP-Address" "10.10.10.1")
          (cons "NAS-Port-Id" 10))
@end group
@end smalllisp

@comment **L2***************************************************************
@node Authentication with Scheme
@subsection Authentication with Scheme
@cindex Authentication with Scheme

The Scheme procedure used for authentication must be declared as
follows:

@deffn {Function Template} auth-function request-list check-list reply-list
Its arguments are:
@table @var
@item request-list
The list of @AVP{}s from the incoming request
@item check-list
The list of @AVP{}s from the @LHS{} of the profile entry that matched
the request
@item reply-list
The list of @AVP{}s from the @RHS{} of the profile entry that matched
the request
@end table
@end deffn

The function return value determines whether the authentication will
succeed. The function must return either a boolean value or a pair.
The return of @code{#t} causes authentication to succeed. The return
of @code{#f} causes it to fail.

For a function to add something to the reply @AVP{}s, it
should return a pair in the form

@smalllisp
    (cons @var{return-code} @var{list})
@end smalllisp

@noindent
where @var{return-code} is a boolean value of the same meaning as
described above. @var{list} is a list of @AVP{}s to be added
to the reply list. For example, the following function will always
deny the authentication, returning an appropriate message to the user:

@exindex Scheme authentication function
@smalllisp
@group
(define (decline-auth request-list check-list reply-list)
  (cons #f
        (list
         (cons "Reply-Message"
               "\r\nSorry, you are not
                allowed to log in\r\n"))))
@end group
@end smalllisp

As a more constructive example, let's consider a function that
allows the authentication only if a user name is found in its
internal database:

@smalllisp
@group
(define staff-data
  (list
   (list "scheme"
         (cons
          (list (cons "NAS-IP-Address" "127.0.0.1"))
          (list (cons "Framed-MTU" "8096")))
         (cons
          '()
          (list (cons "Framed-MTU" "256"))))))

(define (auth req check reply)
  (let* ((username (assoc "User-Name" req))
         (reqlist (assoc username req))
         (reply-list '()))
    (if username
        (let ((user-data (assoc (cdr username) staff-data)))
          (rad-log L_INFO (format #f "~A" user-data))
          (if user-data
              (call-with-current-continuation
               (lambda (xx)
                 (for-each
                  (lambda (pair)
                    (cond
                     ((avl-match? req (car pair))
                      (set! reply-list (avl-merge
                                        reply-list
                                        (cdr pair)))
                      (xx #t))))
                  (cdr user-data))
                 #f)))))
    (cons
     #t
     reply-list)))
@end group
@end smalllisp

To trigger the invocation of the Scheme authentication function, assign
its name to the @attr{Scheme-Procedure} attribute in the @RHS{} of a
corresponding @file{raddb/users} profile. For example:

@exindex Invoking Scheme authentication function
@exindex Scheme authentication function, invocation
@example
@group
DEFAULT Auth-Type = SQL
        Scheme-Procedure = "auth"
@end group
@end example

@comment **L2***************************************************************
@node Accounting with Scheme
@subsection Accounting with Scheme
@cindex Accounting with Scheme

The Scheme accounting procedure must be declared as follows:

@deffn {Function Template} acct-function-name request-list
Its argument is:
@table @var
@item request-list
The list of @AVP{}s from the incoming request
@end table
@end deffn

The function must return a boolean value. The accounting succeeds only
if it has returned @code{#t}.

Here is an example of a Scheme accounting function. The function dumps
the contents of the incoming request to a file:

@exindex Scheme accounting function
@smalllisp
@group
(define radius-acct-file "/var/log/acct/radius")

(define (acct req)
  (call-with-output-file radius-acct-file
    (lambda (port)
      (for-each (lambda (pair)
                  (display (car pair) port)
                  (display "=" port)
                  (display (cdr pair) port)
                  (newline port))
                req)
      (newline port)))
  #t)
@end group
@end smalllisp

@comment **L2***************************************************************
@node Radius-Specific Functions
@subsection Radius-Specific Functions
@cindex Radius-Specific Scheme Functions

@deffn {Scheme Function} avl-delete av-list attr
Delete from @var{av-list} the pairs with attribute @var{attr}.
@end deffn

@deffn {Scheme Function} avl-merge dst src
Merge @var{src} into @var{dst}.
@end deffn

@deffn {Scheme Function} avl-match? target list
Return @code{#t} if all pairs from @var{list} are present in @var{target}.
@end deffn

@deffn {Scheme Function} rad-dict-name->attr name
Return a dictionary entry for the given attribute @var{name} or @code{#f} if
no such name was found in the dictionary.

A dictionary entry is a list in the form

@deffn {Scheme List} dict-entry name-string attr-number type-number vendor

@noindent
where the arguments are as follows:

@table @var
@item name-string
The attribute name
@item value-number
The attribute number
@item type-number
The attribute type
@item vendor
The vendor @acronym{PEC}, if the attribute is a vendor-specific one,
or @code{#f} otherwise.
@end table
@end deffn
@end deffn

@deffn {Scheme Function} rad-dict-value->name attr value
Returns the dictionary name of the given @var{value} for an integer-type
attribute @var{attr}, which can be either an attribute number
or its dictionary name.
@end deffn

@deffn {Scheme Function} rad-dict-name->value attr value
Convert a symbolic attribute value name into its integer representation.
@end deffn

@deffn {Scheme Function} rad-dict-pec->vendor pec
Convert a @acronym{PEC} to the vendor name.
@end deffn

@deffn {Scheme Function} rad-log-open prio
Open Radius logging to the severity level @var{prio}.
@end deffn

@deffn {Scheme Function} rad-log-close
Close a Radius logging channel opened by a previous call to @code{rad-log-open}.
@end deffn

@deffn {Scheme Function} rad-rewrite-execute-string string
Interpret @var{string} as an invocation of a function in Rewrite language and
execute it.

Return value: return of the corresponding Rewrite call, translated to
the Scheme data type.
@end deffn

@deffn {Scheme Function} rad-rewrite-execute arglist
Execute a Rewrite language function.
@code{(car @var{arglist})} is interpreted as a name of the Rewrite
function to execute, and @code{(cdr @var{arglist})} as a list of
arguments to be passed to it.

Return value: return of the corresponding Rewrite call, translated to
the Scheme data type.
@end deffn

@deffn {Scheme Function} rad-openlog ident option facility
Scheme interface to the system @code{openlog()} call.
@end deffn

@deffn {Scheme Function} rad-syslog prio text
Scheme interface to the system @code{syslog()} call.
@end deffn

@deffn {Scheme Function} rad-closelog
Scheme interface to the system @code{closelog()} call.
@end deffn

@deffn {Scheme Function} rad-utmp-putent status delay list radutmp_file radwtmp_file
Write the supplied data into the radutmp file. If @var{radwtmp_file} is not nil,
the constructed entry is also appended to @var{wtmp_file}.

@var{list} is:

@deffn {Scheme List} utmp-entry user-name orig-name port-id port-type session-id caller-id framed-ip nas-ip proto

@table @var
@item user-name
The user name
@item orig-name
The original user name from the request
@item port-id
The value of the @attr{NAS-Port-Id} attribute
@item port-type
A number or character indicating the port type
@item session-id
The session @sc{id}
@item caller-id
The value of the @attr{Calling-Station-Id} attribute from the request
@item framed-ip
The framed IP assigned to the user
@item nas-ip
The @NAS{} IP
@item proto
A number or character indicating the type of the connection
@end table
@end deffn
@end deffn
